log/
	Base modules specific to logging
xdb/
	Base modules specific to xdb
io/
	Base modules providing new IO methods
gen/
	Base modules providing general functionality


once config is loaded, all base modules are (loaded and) initialized.  during init, they use cfreg("node",my_func,arg) to receive config file commands.

config file is then checked to make sure it's valid and fully handled, then registered handlers in the base modules are executed.  they then start any threads or do any init they need to do, and register handlers for incoming packets.
(packets come in from the base modules too, passed to deliver())

packets are delivered based on ptype, then on the idnode (config file section), then on the registered handlers for that section.

handlers can either return R_PASS (continue), R_OK (done processing and packet delivered), or R_ERR (stop processing because of failure)

issue: when base modules receive packets to handle, they often need to know which host it was for (because they don't control this, the config does)
they shouldn't try and check the config, they simply need to look at the dpacket->host or the to="" in the xml, duh :)

base modules should never use libetherx, replace with custom internal pth functions... but for base_load, the so's it loads may require that lib or any other lib

Example packets:

<log type="notice" from="jabber.org">User foo@jabber.org hit message rate limit</log>
(from="_internal" for logs from entities that are not services, such as an xdb or internally in jabberd or in a base module)
(never have a to="" attrib, from is set by originator)

<xdb type="get" to="foo@jabber.org" from="jabber.org"><vCard xmlns="jabber:iq:vcard-temp">...</vCard></xdb>
(all get/set's are routed to the xdb handler based on the to host, all results are sent to the service identified in the from)


---------- RANT on session routing
for an auth iq, set the from="45a3@10348.polld.jabber.org" to identify the session id within the connection service
set the sid="jabber.org" to identify the hostname that should be handling the service.
return packets from the manager service can then set sid="" to the from, and set the from="4015@farm03.jabber.org" to identify the session id within the manager service.
subsequent packets addressed to either session can be identified, and the other's sid is stored within each session.
sid="" is used in place of the to="" attribute, and only valid within polld.
if a service receives a packet because of a sid="" and it doesn't handle sessions, it should notice the sid="" attrib and bounce it

all packets are bounced intelligently, xdbs returned empty, logs not bounced, and packets bounced like normal (with type="error", etc)

----------- RANT ON SERVER2SERVER DIALBACK, IGNORE
A box(5ae8) on the jabber.com server farm has a packet to send to jabber.org, opens socket and sends:
<spam to="jabber.org" from="5ae8@jabber.com" id="8f" start="e4ee62250deec8b78e7993f8e4433ce1dec50d7e" seq="1000"/>
The jabber.com server stores the id and sequence associated with "jabber.org" for later validation.

Jabber.org responds to the spam, noticing that jabber.com want's to send it some data, and allows by sending it some spam:
<spam to="5ae8@jabber.com" from="jabber.org" id="c2" start="b8dd9a886e4286e4528d935134b62f536605e305" seq="500" spam="8f:56454c9898256fd425e1af3c898f953a89d52be5"/>
The spam="" attrib's latter part is a sha1 hash of the id+start+seq.  Jabber.com

use secret to build start, date in it for auto-expiration, bounce with new 500 error for spam

Phoey!  Making a mountain out of a molehill... 
When host jabber.com has packets to send to jabber.org: A connects to B and sends:
<spam to="jabber.org" from="5ae8@jabber.com"/> (asks jabber.org to trust jabber.com, with additional routing information about which server requires the trust)
<trust to="jabber.org" from="jabber.com"/> (tells jabber.org that jabber.com trusts packets from it over this socket)
jabber.org receives the spam, and in order to trust packets from jabber.com it does a dns resolve and connects to jabber.com and sends:
<trust to="5ae8@jabber.com" from="jabber.org"/>
jabber.org can already send packets to jabber.com from the previous trust on the other socket, so it doesn't need to ask for it.
The sockets should idle-timeout disconnect as well as disconnect on a regular basis, in case of dns hijacking or changes and new IPs.
Should each <spam/> result in a new connection, or can a server notice that it already has a socket to that IP and send another trust over it?
(what if socket is broken and server doesn't know it yet (remote reboot or redundant server kick-in on same IP, or other goofyness?), new socket help?)
(if new socket, could be a DOS connect attack)
Limit the # of <spam/>'s sent on a single socket, one or how many? (DOS attack possibilities as well)

A->B (trusts B and passes X) B->A (trusts A and asks for X)  if X matches, B trusts the original connection from A

--------- RANT on mass virtual hosting
by using a <host/> in a session handler section, it will receive a copy of EVERY outgoing packet (to other servers), and if it uses xdb to lookup the host to see if it handles it, wow, that sucks
better way would be to write a base module that does the db lookup (and can update when it changes) and registers the idnode w/ the right hostnames in the db.

