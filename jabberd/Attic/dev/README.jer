log/
	Base modules specific to logging
xdb/
	Base modules specific to xdb
io/
	Base modules providing new IO methods
gen/
	Base modules providing general functionality


once config is loaded, all base modules are (loaded and) initialized.  during init, they use cfreg("node",my_func,arg) to receive config file commands.

config file is then checked to make sure it's valid and fully handled, then registered handlers in the base modules are executed.  they then start any threads or do any init they need to do, and register handlers for incoming packets.
(packets come in from the base modules too, passed to deliver())

packets are delivered based on ptype, then on the idnode (config file section), then on the registered handlers for that section.

handlers can either return R_PASS (continue), R_OK (done processing and packet delivered), or R_ERR (stop processing because of failure)

issue: when base modules receive packets to handle, they often need to know which host it was for (because they don't control this, the config does)
they shouldn't try and check the config, they simply need to look at the dpacket->host or the to="" in the xml, duh :)

base modules should never use libetherx, replace with custom internal pth functions... but for base_load, the so's it loads may require that lib or any other lib

Example packets:

<log type="notice" from="jabber.org">User foo@jabber.org hit message rate limit</log>
(from="_internal" for logs from entities that are not services, such as an xdb or internally in jabberd or in a base module)
(never have a to="" attrib, from is set by originator)

<xdb type="get" to="foo@jabber.org/jabber:iq:vcard-temp" id="returnID" from="jabber.org"><vCard xmlns="jabber:iq:vcard-temp">...</vCard></xdb>
<xdb type="result" id="returnID" to="jabber.org" from="foo@jabber.org/jabber:iq:vcard-temp"><vCard xmlns="jabber:iq:vcard-temp">...</vCard></xdb>
(all get/set's are routed to the xdb handler based on the to host, all results are delivered to the SERVICE identified in the from)

XXX - issue on handling errors for xdb results, for get and set

---------- RANT on packet handlers
copying packets is expensive, so we want to minimize copies.  it has to be determined *beforehand* that a copy should be made,
so for ease it's just hard-wired that the o_DELIVER will be responsible for freeing the packet, and if there are multiple ones they are given copies
the packet also needs to be flagged as "handled" or not, which is the return result from the handlers
a packet is only handled when ANY handler (even if it's just an o_PRECOND) returns an r_OK
handling is stopped upon an r_ERR or r_LAST, and no change with r_PASS
r_ERR means the handler actually modified the packet appropriately to represent the error

---------- RANT on session routing
for an auth iq, set the from="45a3@10348.polld.jabber.org" to identify the session id within the connection service
set the sid="jabber.org" to identify the hostname that should be handling the service.
return packets from the manager service can then set sid="" to the from, and set the from="4015@farm03.jabber.org" to identify the session id within the manager service.
subsequent packets addressed to either session can be identified, and the other's sid is stored within each session.
sid="" is used in place of the to="" attribute, and only valid within polld.
if a service receives a packet because of a sid="" and it doesn't handle sessions, it should notice the sid="" attrib and bounce it

all packets are bounced intelligently, xdbs returned empty, logs not bounced, and packets bounced like normal (with type="error", etc)

----------- RANT on groupchat
clients must ALWAYS send available presence BEFORE the second iq registration w/ the room, so the gcserv knows they are avail and when they go unavail
actually USING presence is optional, flagged with <presence/>
mailing list "mode", flagged with <subscribe/> and <unsubscribe/>, requires further integration w/ browsing model for "live bookmarks" and such

----------- RANT on live bookmarks (non-items in roster, browsing model)
what do we need?  well, some way of making it easy, almost transparent/automatic, for any browsed-to entity to express that they should 
be "bookmarked", this would be for registered transports, mailing list mode groupchats, etc... 
BUT, the problem is that the exact time in which the need for the bookmarking happens is not the same, it needs to act like a presence s10n request
AND, the bookmarked entity needs to retain it's browseable wrapper when stored in the roster, and possible know presence and know when it's removed too
I could hack up presence to do this, but that's ugly and presence is not always used by the entities
Clients could also have hardwired the special cases when bookmarking should happen and the entities could flag it in those conversations,
but that's ugly for client authors and special purpose per-issue, when this seems like a more general problem


----------- RANT ON SERVER2SERVER DIALBACK, IGNORE
A box(5ae8) on the jabber.com server farm has a packet to send to jabber.org, opens socket and sends:
<spam to="jabber.org" from="5ae8@jabber.com" id="8f" start="e4ee62250deec8b78e7993f8e4433ce1dec50d7e" seq="1000"/>
The jabber.com server stores the id and sequence associated with "jabber.org" for later validation.

Jabber.org responds to the spam, noticing that jabber.com want's to send it some data, and allows by sending it some spam:
<spam to="5ae8@jabber.com" from="jabber.org" id="c2" start="b8dd9a886e4286e4528d935134b62f536605e305" seq="500" spam="8f:56454c9898256fd425e1af3c898f953a89d52be5"/>
The spam="" attrib's latter part is a sha1 hash of the id+start+seq.  Jabber.com

use secret to build start, date in it for auto-expiration, bounce with new 500 error for spam

Phoey!  Making a mountain out of a molehill... 
When host jabber.com has packets to send to jabber.org: A connects to B and sends:
<spam to="jabber.org" from="5ae8@jabber.com"/> (asks jabber.org to trust jabber.com, with additional routing information about which server requires the trust)
<trust to="jabber.org" from="jabber.com"/> (tells jabber.org that jabber.com trusts packets from it over this socket)
jabber.org receives the spam, and in order to trust packets from jabber.com it does a dns resolve and connects to jabber.com and sends:
<trust to="5ae8@jabber.com" from="jabber.org"/>
jabber.org can already send packets to jabber.com from the previous trust on the other socket, so it doesn't need to ask for it.
The sockets should idle-timeout disconnect as well as disconnect on a regular basis, in case of dns hijacking or changes and new IPs.
Should each <spam/> result in a new connection, or can a server notice that it already has a socket to that IP and send another trust over it?
(what if socket is broken and server doesn't know it yet (remote reboot or redundant server kick-in on same IP, or other goofyness?), new socket help?)
(if new socket, could be a DOS connect attack)
Limit the # of <spam/>'s sent on a single socket, one or how many? (DOS attack possibilities as well)

A->B (trusts B and passes X) B->A (trusts A and asks for X)  if X matches, B trusts the original connection from A

oops, went TOO far, if you put a C in the middle it can fake itself easily, let's try something different

we just want to guarantee names, can we use secure-DNS for this stuff?
or, run a public key service on a standard port which just serves the public key
A->B and says it wants to spam, "challenge me", B sends A on that socket a text challenge, and at the same time connects to A on the pubkey port to get the public key
A returns to B the challenge signed, and B can validate w/ the (only secure as the domain name at that time) retrieved public key

--------- RANT on mass virtual hosting
by using a <host/> in a session handler section, it will receive a copy of EVERY outgoing packet (to other servers), and if it uses xdb to lookup the host to see if it handles it, wow, that sucks
better way would be to write a base module that does the db lookup (and can update when it changes) and registers the idnode w/ the right hostnames in the db.

